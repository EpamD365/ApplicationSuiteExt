<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BusinessEventsCDSSyncHelperExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.IO;
using System.Runtime.Serialization.Json;
using System.Text;
using Microsoft.Dynamics.ApplicationPlatform.XppServices.Instrumentation;
using Microsoft.Dynamics.Ax.Xpp.Dataverse;
using Microsoft.Dynamics.Ax.Xpp.Dataverse.Contracts;

/// <summary>
/// Helper class for Business Events Sync logic with CDS
/// </summary>
public static class BusinessEventsCDSSyncHelperExt
{
    private const int defaultTimeoutInSeconds = 1 * 60; // 1 minute
    private const int maxRetryNumber = 3;
    private const str changeRequestsExistFlag = 'ChangeRequestsExist';

    private const str GlobalCacheScope = classStr(BusinessEventsCDSSyncHelperExt);
    private const str FullSyncInProgressKey = "FullSyncInProgress";

    /// <summary>
    /// Session static flag to determine if the given session should skip syncing to CDS.
    /// This will be set to true in the create, update, and delete methods of the following entities
    /// used by CDS for writing to the Business Events framework and eventually for BusinessEvents ALM (moving config between environments):
    /// - <c>BusinessEventsConfigurationEntity</c>
    /// - <c>BusinessEventsEndpointEntity</c>
    ///
    /// This flag is intended to be consumed by code that needs to determine if the current action should skip syncing to CDS
    /// (i.e if the current request is from CDS then sync back to CDS should be skipped avoiding a cycle)
    /// </summary>
    public static boolean skipCdsSync = false;

    /// <summary>
    /// Session static flag to determine if the CDSContext.IsCdsManaged property should be validated when deleting
    /// <c>BusinessEventsConfiguration</c> and <c>BusinessEventsEndpoint</c> records
    /// This will be set to true while deleting records in the following forms
    /// - <c>BusinessEventsWorkspaceActiveConfigurationPart</c>
    /// - <c>BusinessEventsWorkspaceInactiveConfigurationPart</c>
    /// - <c>BusinessEventsWorkspaceEndpointPart</c>
    ///
    /// The flag is intended to be consumed by the code while we validate delete in BEConfiguation and BEEndpoint tables
    /// </summary>
    public static boolean validateIsCdsManagedOnDelete =  false;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isEndpointTypeSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the provided endpoint type is supported for sync.
    /// </summary>
    /// <param name = "_endpointType">The endpoint type</param>
    /// <returns>True if the endpoint type is supported for sync to CDS. False, otherwise</returns>
    public static boolean isEndpointTypeSupported(BusinessEventsEndpointType _endpointType)
    {
        switch (_endpointType)
        {
            case BusinessEventsEndpointType::AzureServiceBusQueue:
            case BusinessEventsEndpointType::AzureServiceBusTopic:
            case BusinessEventsEndpointType::AzureEventGrid:
            case BusinessEventsEndpointType::AzureEventHub:
            case BusinessEventsEndpointType::Flow:
            case BusinessEventsEndpointType::Http:
                return true;
                break;
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullSyncInProgress</Name>
				<Source><![CDATA[
    public static boolean isFullSyncInProgress()
    {
        boolean isFullSyncInProgress;
        SysGlobalobjectCache sgoc = new SysGlobalObjectCache();

        [isFullSyncInProgress] = sgoc.find(GlobalCacheScope, [FullSyncInProgressKey]);

        return isFullSyncInProgress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queueFullSyncRequest</Name>
				<Source><![CDATA[
    public static void queueFullSyncRequest(FnoComponentType _componentType, int _timeoutInSeconds = defaultTimeoutInSeconds)
    {
        if (BusinessEventsFlights::IsBusinessEventsCDSIntegrationEnabled())
        {
            BusinessEventsCDSComponentChangeRequest changeRequest;

            changeRequest.ComponentChangeType = ComponentChangeType::Unknown;
            changeRequest.ComponentType = _componentType;
            changeRequest.ExternalId = "*";
            changeRequest.TimeoutInSeconds = _timeoutInSeconds;
            changeRequest.UserId = curUserId();
            changeRequest.IsFullSync = NoYes::Yes;

            changeRequest.insert();

            // Set that some changeRequest exists to send after the next tts commit
            appl.globalCache().set(GlobalCacheScope, changeRequestsExistFlag, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends a change request immediatly to CDS
    /// </summary>
    /// <param name = "_changeRequest">The <c>ComponentChangeRequest</c></param>
    /// <param name = "_timeoutInSeconds">The timeout this sync request should have when synced</param>
    public static void sendChangeRequest(ComponentChangeRequest _changeRequest, int _timeoutInSeconds = defaultTimeoutInSeconds)
    {
        if (BusinessEventsFlights::IsBusinessEventsCDSIntegrationEnabled())
        {
            RefreshProviderComponentsRequest request = new RefreshProviderComponentsRequest();
            var changes = request.Changes;
            changes.Add(_changeRequest);

            BusinessEventsCDSSyncHelperExt::logRequestToTelemetry(request);
            var result = CdsProxy::SyncComponents(request, _timeoutInSeconds * 1000);

            if (result.IsException())
            {
                var exception = result.GetException();
                var innerException = exception.InnerException;

                FnoComponentType fnoComponentType = _changeRequest.ComponentType;
                ComponentChangeType componentChangeType = _changeRequest.ComponentChangeType;
                str externalId = _changeRequest.ExternalId;
                str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3", fnoComponentType.ToString(), componentChangeType.ToString(), externalId);
                BusinessEventsEventSource::EventWriteCDSSyncException(message, innerException.Message, innerException.Source, innerException.GetType().FullName, innerException.StackTrace);

                throw exception;
            }
            else
            {
                //log the response to telemetry
                str response = result.GetResult().Response;
                BusinessEventsCDSSyncHelperExt::logResponseToTelemetry(response);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queueChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes a change request to the <c>BusinessEventsCDSComponentChangeRequest</c> table for async processing
    /// </summary>
    /// <param name = "_changeRequest">The <c>ComponentChangeRequest</c></param>
    /// <param name = "_timeoutInSeconds">The timeout this sync request should have when synced</param>
    public static void queueChangeRequest(ComponentChangeRequest _changeRequest, int _timeoutInSeconds = defaultTimeoutInSeconds)
    {
        if (BusinessEventsFlights::IsBusinessEventsCDSIntegrationEnabled())
        {
            BusinessEventsCDSComponentChangeRequest changeRequest;

            changeRequest.ComponentChangeType = _changeRequest.ComponentChangeType;
            changeRequest.ComponentType = _changeRequest.ComponentType;
            changeRequest.ExternalId = _changeRequest.ExternalId;
            changeRequest.TimeoutInSeconds = _timeoutInSeconds;
            changeRequest.IsFullSync = NoYes::No;

            changeRequest.insert();

            str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3", _changeRequest.ComponentType.ToString(), _changeRequest.ComponentChangeType.ToString(), _changeRequest.ExternalId);
            BusinessEventsEventSource::EventWriteCDSSyncRequestQueued(message);

            // Set that some changeRequest exists to send after the next tts commit
            appl.globalCache().set(GlobalCacheScope, changeRequestsExistFlag, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>Application_ttsNotifyCommit</Name>
				<Source><![CDATA[
    [SubscribesTo(classstr(Application),delegatestr(Application, onTtsNotifyCommit))]
    public static void Application_ttsNotifyCommit()
    {
        // Only do work on transaction commit if work exists... this needs to be a really cheap check
        if (appl.globalCache().isSet(GlobalCacheScope, changeRequestsExistFlag))
        {
            // Clear the flag since we're done from this event
            appl.globalCache().remove(GlobalCacheScope, changeRequestsExistFlag);

            // Execute the sending of change requests asynchronously on a seperate
            // session, yet still immediately after the transaction commits. This
            // gives real-time performance, but doesn't make the user wait
            // on the call to CDS before proceeding.
            runAsync(classNum(BusinessEventsCDSSyncHelperExt),
                staticMethodStr(BusinessEventsCDSSyncHelperExt, processChangeRequests),
                conNull());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processChangeRequests</Name>
				<Source><![CDATA[
    public static container processChangeRequests(container _params)
    {
        BusinessEventsCDSSyncHelperExt::processFullSyncRequests();
        BusinessEventsCDSSyncHelperExt::processTargetedSyncRequests();

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFullSyncRequests</Name>
				<Source><![CDATA[
    private static void processFullSyncRequests()
    {
        if (BusinessEventsCDSSyncHelperExt::isFullSyncInProgress())
        {
            BusinessEventsCDSSyncHelperExt::processPendingFullSyncRequests();
        }
        else
        {
            BusinessEventsCDSSyncHelperExt::checkForNewFullSyncRequsts();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPendingFullSyncRequests</Name>
				<Source><![CDATA[
    private static void processPendingFullSyncRequests()
    {
        BusinessEventsCDSComponentChangeRequest changeRequest;
        Set recordsToProcess = new Set(Types::Int64);
        Map asyncOperationIdToUserIds = new Map(Types::Guid, Types::String);
        SysGlobalobjectCache sgoc = new SysGlobalObjectCache();
        boolean fullSyncStillPending = false;

        ttsbegin;
        changeRequest.readPast(true);
        while select pessimisticlock changeRequest
            where changeRequest.IsFullSync == NoYes::Yes
            && changeRequest.AsyncOperationId != emptyGuid()
        {
            recordsToProcess.add(changeRequest.RecId);
            if (!asyncOperationIdToUserIds.exists(changeRequest.AsyncOperationId))
            {
                asyncOperationIdToUserIds.add(changeRequest.AsyncOperationId, changeRequest.UserId);
            }
        }

        if (asyncOperationIdToUserIds.elements() == 0)
        {
            //There should be at least one record with an AsyncOperationId, if not, then we should
            //clear the flag and check for any un processed full sync requests
            sgoc.remove(GlobalCacheScope, [FullSyncInProgressKey]);
            BusinessEventsCDSSyncHelperExt::checkForNewFullSyncRequsts();
            return;
        }

        MapEnumerator mapEnum = asyncOperationIdToUserIds.getEnumerator();
        while(mapEnum.moveNext())
        {
            BusinessEventsCDSAsyncOperationId asyncOperationId = mapEnum.current();
            str asyncOperationIdStr = guid2StrWithoutBraces(asyncOperationId);
            //query for current status of the async operation id
            var result = CdsProxy::GetAsyncOperation(asyncOperationIdStr);

            //Check for exception from CDSProxy layer.
            if (result.IsException())
            {
                var exception = result.GetException().InnerException;

                str message = strFmt("Exception while querying status for AsyncOperationId: %1", asyncOperationIdStr);
                BusinessEventsEventSource::EventWriteCDSFullSyncAsyncOperationException(message, asyncOperationIdStr, exception.Message, exception.Source, exception.GetType().FullName, exception.StackTrace);
            }
            else
            {
                //log the response to telemetry
                GetAsyncOperationResponse response = result.GetResult();

                if (response.StateCode == AsyncOperationStateCode::Completed && response.StatusCode == AsyncOperationStatusCode::Succeeded)
                {
                    //If state is completed and status is succeeded, delete the associated records.
                    delete_from changeRequest where changeRequest.AsyncOperationId == asyncOperationId;

                    UserId userId = asyncOperationIdToUserIds.lookup(asyncOperationId);
                    if (userId != "")
                    {
                        //Add message to original user that triggered the sync that the operation is complete
                        Array users = new Array (Types::String);
                        users.value(1, userId);
                        SystemNotificationDataContract notification = new SystemNotificationDataContract();
                        notification.Title("@BusinessEvents:RebuildBusinessEventCatalogComplete");
                        notification.Type(SystemNotificationType::Alert);
                        notification.Severity(SystemNotificationSeverity::Informational);
                        notification.Users(users);
                        int64 id = SystemNotificationsManager::AddNotification(notification);
                    }

                    str message =  strFmt("Full sync completed with AsyncOperationId: %1", asyncOperationIdStr);
                    BusinessEventsEventSource::EventWriteCDSFullSyncAsyncOperationComplete(message, asyncOperationIdStr);
                }
                else
                {
                    //If status is not complete, log telemetry, no-op
                    str message =  strFmt("Full sync still in progress with AsyncOperationId: %1, StatusCode: %2, StateCode: %3", asyncOperationIdStr, response.StatusCode.ToString(), response.StateCode.ToString());
                    BusinessEventsEventSource::EventWriteCDSFullSyncAsyncOperationStatus(message, asyncOperationIdStr);
                    fullSyncStillPending = true;
                }
            }
        }

        if (!fullSyncStillPending)
        {
            sgoc.remove(GlobalCacheScope, [FullSyncInProgressKey]);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForNewFullSyncRequsts</Name>
				<Source><![CDATA[
    private static void checkForNewFullSyncRequsts()
    {
        #OCCRetryCount

        BusinessEventsCDSComponentChangeRequest changeRequest;
        Set recordsToProcess = new Set(Types::Int64);
        SysGlobalobjectCache sgoc = new SysGlobalObjectCache();

        //check for full sync requests.
        try
        {
            RefreshProviderComponentsRequest request = new RefreshProviderComponentsRequest();
            request.ExecuteAsynchronously = true;
            var changes = request.Changes;
            int maxRequestTimeoutInSeconds = defaultTimeoutInSeconds;

            ttsbegin;
            changeRequest.readPast(true);

            while select pessimisticlock changeRequest where changeRequest.IsFullSync == NoYes::Yes
            {
                if (changeRequest.RetryNumber > maxRetryNumber)
                {
                    //Telemetry that this has been retried too many times and won't be retried again.
                    FnoComponentType fnoComponentType = changeRequest.ComponentType;
                    ComponentChangeType componentChangeType = changeRequest.ComponentChangeType;
                    str externalId = changeRequest.ExternalId;
                    str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3, RetryNumber: %4", fnoComponentType.ToString(), componentChangeType.ToString(), externalId, changeRequest.RetryNumber);
                    BusinessEventsEventSource::EventWriteCDSSyncRetrySkipped(message);
                    continue;
                }

                ComponentChangeRequest componentChangeRequest = new ComponentChangeRequest();

                componentChangeRequest.ComponentChangeType = changeRequest.ComponentChangeType;
                componentChangeRequest.ComponentType = changeRequest.ComponentType;
                componentChangeRequest.ExternalId = changeRequest.ExternalId;

                recordsToProcess.add(changeRequest.RecId);
                changes.Add(componentChangeRequest);

                maxRequestTimeoutInSeconds = max(maxRequestTimeoutInSeconds, changeRequest.TimeoutInSeconds);
            }

            if (recordsToProcess.elements() > 0)
            {
                BusinessEventsCDSSyncHelperExt::logRequestToTelemetry(request);
                var result = CdsProxy::SyncComponents(request, maxRequestTimeoutInSeconds * 1000);

                //Check for exception from CDSProxy layer.
                if (result.IsException())
                {
                    SetEnumerator setEnum = recordsToProcess.getEnumerator();
                    while(setEnum.moveNext())
                    {
                        select forupdate changeRequest where changeRequest.RecId == setEnum.current();

                        var exception = result.GetException().InnerException;
                        changeRequest.RetryNumber = changeRequest.RetryNumber + 1;
                        changeRequest.update();

                        FnoComponentType fnoComponentType = changeRequest.ComponentType;
                        ComponentChangeType componentChangeType = changeRequest.ComponentChangeType;
                        str externalId = changeRequest.ExternalId;
                        str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3, RetryNumber: %4", fnoComponentType.ToString(), componentChangeType.ToString(), externalId, changeRequest.RetryNumber);
                        BusinessEventsEventSource::EventWriteCDSSyncException(message, exception.Message, exception.Source, exception.GetType().FullName, exception.StackTrace);
                    }
                }
                else
                {
                    //log the response to telemetry
                    RefreshProviderComponentsResponse response = result.GetResult();
                    BusinessEventsCDSSyncHelperExt::logResponseToTelemetry(response.Response);
                    BusinessEventsCDSAsyncOperationId asyncOperationId = response.AsyncOperationId;
                    if (asyncOperationId != emptyGuid())
                    {
                        SetEnumerator setEnum = recordsToProcess.getEnumerator();
                        while(setEnum.moveNext())
                        {
                            select forupdate changeRequest where changeRequest.RecId == setEnum.current();

                            // Update the change request with the AsyncOperationId
                            changeRequest.AsyncOperationId = asyncOperationId;
                            changeRequest.update();
                        }

                        str asyncOperationIdStr = guid2StrWithoutBraces(asyncOperationId);
                        str message =  strFmt("Full sync queued with AsyncOperationId: %1", asyncOperationIdStr);
                        BusinessEventsEventSource::EventWriteCDSFullSyncAsyncOperationQueued(message, asyncOperationIdStr);

                        //Set the SGOC with the global flag that a full sync is in progress.
                        sgoc.insert(GlobalCacheScope, [FullSyncInProgressKey], [true]);
                    }
                    else
                    {
                        // no Async Operationid was returned means that the request was processed synchronously and can be deleted
                        SetEnumerator setEnum = recordsToProcess.getEnumerator();
                        while(setEnum.moveNext())
                        {
                            select forupdate changeRequest where changeRequest.RecId == setEnum.current();

                            changeRequest.delete();
                        }
                    }
                }
            }
            ttscommit;

        }
        #StandardRetryCatchBlock

    }

]]></Source>
			</Method>
			<Method>
				<Name>processTargetedSyncRequests</Name>
				<Source><![CDATA[
    private static void processTargetedSyncRequests()
    {
        #OCCRetryCount

        if (BusinessEventsCDSSyncHelperExt::isFullSyncInProgress())
        {
            //no-op. need to block execution of targeted sync reqeusts until the full sync completes
            return;
        }

        // Process all existing change requests using pessimistic locking with readpast so
        // that we process things right away, but also retry any that might have been
        // orphaned due to a crash at the wrong instant. In practice we should add
        // the event time, number of retries, etc, etc. For now it's just a dumb "try it".
        // If another thread picks up our change requests first, that doesn't matter. The
        // readpast means we'll ignore them and the other thread will send them. We
        // just need *some* thread to try right away to avoid any unnecessary latency.

        BusinessEventsCDSComponentChangeRequest changeRequest;
        Set recordsToSync = new Set(Types::Int64);

        try
        {
            RefreshProviderComponentsRequest request = new RefreshProviderComponentsRequest();
            var changes = request.Changes;
            int maxRequestTimeoutInSeconds = defaultTimeoutInSeconds;

            ttsbegin;
            changeRequest.readPast(true);
            while select pessimisticlock changeRequest where changeRequest.IsFullSync == NoYes::No
            {
                if (changeRequest.RetryNumber > maxRetryNumber)
                {
                    //Telemetry that this has been retried too many times and won't be retried again.
                    FnoComponentType fnoComponentType = changeRequest.ComponentType;
                    ComponentChangeType componentChangeType = changeRequest.ComponentChangeType;
                    str externalId = changeRequest.ExternalId;
                    str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3, RetryNumber: %4", fnoComponentType.ToString(), componentChangeType.ToString(), externalId, changeRequest.RetryNumber);
                    BusinessEventsEventSource::EventWriteCDSSyncRetrySkipped(message);
                    continue;
                }

                ComponentChangeRequest componentChangeRequest = new ComponentChangeRequest();

                componentChangeRequest.ComponentChangeType = changeRequest.ComponentChangeType;
                componentChangeRequest.ComponentType = changeRequest.ComponentType;
                componentChangeRequest.ExternalId = changeRequest.ExternalId;

                recordsToSync.add(changeRequest.RecId);
                changes.Add(componentChangeRequest);

                maxRequestTimeoutInSeconds = max(maxRequestTimeoutInSeconds, changeRequest.TimeoutInSeconds);
            }

            if (recordsToSync.elements() > 0)
            {
                BusinessEventsCDSSyncHelperExt::logRequestToTelemetry(request);
                var result = CdsProxy::SyncComponents(request, maxRequestTimeoutInSeconds * 1000);

                //Check for exception from CDSProxy layer.
                if (result.IsException())
                {
                    SetEnumerator setEnum = recordsToSync.getEnumerator();
                    while(setEnum.moveNext())
                    {
                        select forupdate changeRequest where changeRequest.RecId == setEnum.current();

                        var exception = result.GetException().InnerException;
                        changeRequest.RetryNumber = changeRequest.RetryNumber + 1;
                        changeRequest.update();

                        FnoComponentType fnoComponentType = changeRequest.ComponentType;
                        ComponentChangeType componentChangeType = changeRequest.ComponentChangeType;
                        str externalId = changeRequest.ExternalId;
                        str message = strFmt("ComponentType: %1, ComponentChangeType: %2, ExternalId: %3, RetryNumber: %4", fnoComponentType.ToString(), componentChangeType.ToString(), externalId, changeRequest.RetryNumber);
                        BusinessEventsEventSource::EventWriteCDSSyncException(message, exception.Message, exception.Source, exception.GetType().FullName, exception.StackTrace);
                    }
                }
                else
                {
                    //log the response to telemetry
                    str response = result.GetResult().Response;
                    BusinessEventsCDSSyncHelperExt::logResponseToTelemetry(response);

                    SetEnumerator setEnum = recordsToSync.getEnumerator();
                    while(setEnum.moveNext())
                    {
                        select forupdate changeRequest where changeRequest.RecId == setEnum.current();

                        // Delete the change request only if successfully sent to CDS
                        changeRequest.delete();
                    }
                }
            }
            ttscommit;

        }
        #StandardRetryCatchBlock
    }

]]></Source>
			</Method>
			<Method>
				<Name>logRequestToTelemetry</Name>
				<Source><![CDATA[
    private static void logRequestToTelemetry(RefreshProviderComponentsRequest request)
    {
        //Serialize request to string and log for telemetry if needed
        str message;
        System.Type serType = request.GetType();
        DataContractJsonSerializer responseSerializer = new DataContractJsonSerializer(serType);
        using (MemoryStream ms = new MemoryStream())
        {
            responseSerializer.WriteObject(ms, request);

            // The DataContractJsonSerializer.WriteObject() method writes in UTF8
            message = Encoding::UTF8.GetString(ms.ToArray());
        }
        BusinessEventsEventSource::EventWriteCDSSyncRequest(message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logResponseToTelemetry</Name>
				<Source><![CDATA[
    private static void logResponseToTelemetry(str response)
    {
        BusinessEventsEventSource::EventWriteCDSSyncResponse(response);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>